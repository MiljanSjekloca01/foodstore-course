Kurs Total ~ 8 sati			

				Video 1		

Naucicu kreiranje Komponenti, Express Router za API, Angular Router, Mongo DB Atlas - baza.
Reactivne forme i HTTP, RXJS, Json Web Token,   Deploy on Heroku, Koriscenje PayPal

Stvari koje cemo koristiti i trebaju se instalirati :

Git,VSCode,NodeJs,Postman
Angular Essentials - ekstenzija

git git-scm.com

Angular Essentials - Extension pack,Vise ekstenzija zajedno koje su dobre za rad sa Angularom i korisne

CTRL SHIFT P - file icon theme - material icon theme koji smo dobili iz angular essentials za izgled
fajlova




				Video 2

kreiramo angular frontent  ng new frontend --skip-tests ja msm i Yes na Angular Routing posto cemo ga koristiti

ng serve -o da otvori i browser odma sa localhost 4200

rm -rf .git uklanjanje gita iz frontenda jer cemo ga imati na nivou cijele aplikacije


Video 3

Dodavanje Headera, Generisanje Komponente, HTML i CSS 

On dodao README.md

ng g c components/partials/header


Ctrl A za selektovanje cijelog koda

rem i em su otprilike ista stvar samo se rem odnosi na root a em na trenutni roditeljski element

Dodavanje CSS-a i HTML u header komponentu kao i u glavni style.css dodavanje fonta preko api.
i nekih osnovnih css naredbi


				Video 4

Cilj - List Foods, Food Model, Data.ts,Dodati primjer hrane, Dodati slike kao atribut, Food service
i Kreiranje Home Komponente , ts,html,css

kreiramo shared folder jer ce tu biti vrv model ili nesto sto je sherovano izmedju komponenti

kreiramo model Food
id!  - oznacava da je id required
tags? - oznacava opcioni parametar 

Koristicemo sample data jer nemamo bekend trenutno i zato cemo koristiti data.ts
ili ti sample foods to jest array od vise food modela koje cemo kasnije vrv iz baze podataka vaditi ili tako nesto

Uzeo sam njegove podatke sa gita i slike, nakon toga kreiramo food service.

ng g s services/food - preko terminala kreiramo servis

Injectujemo servis preko construktora i kada smo u home komponentu dopremili food array
krecemo sa ngFor da izlistavamo sve.

<ul>
    <li *ngFor="let food of foods">
        <a routerLink="/food/{{food.id}}"></a>
    </li>
</ul> 

a link ce biti link za svaki food id posebno gdje ce biti opsirnije opisani vrv. ( food details)

<span class="favorite {{food.favorite?'' :'not'}}">  ako je food favorite true onda nista ako nije dodajemo not
kao klasu

npm install ng-starrating --force   - Paket koji cemo da koristim za zvezdice. Njega importujemo preko
RatingModula u app modul


				Video 5


Cilj:  Search Foods,Dodavanje search metode u food service,search route,search result u home componenti
i Generisanje search komponente njen ts html i css.

Napravili smo metodu koja filtrira po food.name-u
Onda smo napraviti rutu za search i stavili home componentu kao home rutu.

ActivatedRoute je servis koji dolazi iz angular router,Servis activated route nam omogucava da dobijemo informacije
o ruti, kao sto su parametri(searchParameter) 

Subscribe znaci kad god se params promjene da se pozove funkcija

activatedRoute.params.subscribe

if(params.searchTerm)   izbacuje error ili staviti searchterm  u ["searchterm"] ili disablovati error
u tsconfig.json stavimo noPropertyAccessFromIndexSignature na false


#s - referenca u inputu iz koje mozemo da dovucemo vrednost input polja.
Umjesto njega moze da se koristi [(ngModel)] ali ovako je jednostavnije. posto nama samo ta vrednost treba
u pozivu funkcije koja se desava na klik dugmeta.

#s - referenca se ne moze koristiti iz komponente samo unutar HTML sablona

(keyup.enter)=""  - svaki put kad pritisnemo enter i pustimo ga poziva npr funkciju

**** Mozda uraditi kad nema nicega u search i kad se klikne enter da vrati sve


			
				Video 6

Cilj: Food Detail Page
Dodavanje metode u food service
generisati food page content dodati ga u rute, ts ,html i css


.container > *{}   - sva djeca prvog nivoa od containera ce imati ovaj css

 .price::before{
    content: "Price: ";
    color: darkgray;
}

- CSS pseudo element before za elemente sa klasom .price
::before - da bi se dodao sadrzaj prije samog elementa.


				Video 7


Cilj: Tags Bar 
Kreiranje tag modela, dodavanje sample tagova u data.ts 
Dodavanje metoda povezanim sa tagom u food service
Dodavanje tagove u rute
Pokazati tag rezultate u home komponenti
Generisati tag komponentu
dodati je u home komponent,dodati ts,html,css

{ path: "tag/:tag", component: HomeComponent}      : - oznacavaju da je tag parametar



				Video 8


Cilj:  Cart Page

CartItem Model, Cart Model
Cart Service, Add to cart button, Cart page component,route,ts,html,css

Umjesto ovoga 
import { Food } from "./Food";

export class CartItem{
    constructor(public food:Food){
        this.food = food;
    }
   food!: Food; 
    quantity:number = 1;
    price: number = this.food.price;

}

Mozemo pojednostaviti i samo u kontruktoru staviti public 

export class CartItem{
    constructor(public food:Food){}
    quantity:number = 1;
    price: number = this.food.price;

}
ng g s services/cart - kreiranje cart servisa
@Injectable({
  providedIn: 'root'
})

- Je ekvivalentno stavljanju servisa u providers: u app module.

RxJs    *** TIP pogledati video o observables,subject,behavioursubject od istog lika mozes.

** BehaviorSubject je deo angularovog sistema za upravljanje stanjem,koristi se za djeljenje podataka
izmedju komponenata ili servisa. ( Subject ) cuva trenutnu vrednost i obavestava sve svoje trenutne
subscribere(pretplacenike) svaki put kad dodje do promene vrednosti.

Treba da ima inicijalnu vrednost ( new BehaviorSubject.. ) 
Cuva trenutnu vrednost pamti je i kada se neko prijavi ili subsc dobice poslednju sacuvanu vrednost.
Svaki put kada se vrednost promjeni svi subscriberi ce biti obavesteni i dobijaju novu vrednost

Pracenje vrednosti necega,i obavjestavanje subscribera po promjeni ali i zadrzavanje vrednosti.
Subject npr nema inicijalnu vrednost i ne zadrzava vrednost.

Znaci BehaviourSubject je mnogo fleksibilni i najcesce vise koristen

Slicno Observable samo mozda unapredjen koncept.
Samo sto Observable prati tok dogadjaja bez pamcenja.


Definisanje metoda u cart servise za dodavanje u korpu,uklanjanja iz korpe,promjene quanity nekog
itema,ciscenje korpe i
 // Reagovanje na promene u korpi preko servisa.
  // Nema manipulacije nad vrednostima
  // Posto observable moze samo da se prati
  getCartObservable():Observable<Cart>{
    return this.cartSubject.asObservable();
  }

I Funkcije za cuvanje korpe u localstorage da se ne bi izgubili podatci na refresh




			Video 9 

Nastavak Cart page-a

Cilj: ostaje isti ts,html,css koji nismo uradili 
Kreiramo title komponentu kao parcijalni dio,i on ce biti na pocetku naseg karta

@Input() - Dekorator koji se koristi kako bi se oznacila svojstva komponente koja prihvata vrednost
preko atributa od roditeljske komponente.

npr imamo komponentu kojoj je selektor app-child
<app-child [message]="parentMessage"></app-child>   
export class ChildComponent {
  @Input() message: string;
}

Donekle input predstavlja atribute koje koristimo ili ti neka svojstva koja mozemo da promjenimo
kada pozivamo selektor te komponente u roditeljskoj komponenti.

ul li:last-child{   - gadjanje zadnjeg li elementa.
    border:none;   
}

li div:not(:first-child){   -li div koji nije first child
    
}

*** Prostudirati flex-grow, flex-shrink.

flex-grow - rast - zauzimanje preostalog prostora
ako imamo 2 elementa jedan ima flex-grow 2 drugi 1 prvi ce uzet duplo vise prostora od drugog
isto tako i za smanjivanje moze kad se smanjuje da jedan element uzme vise drugi manji itd.

checkout>div - samo prvu direktnu decu sa elementom klase checkout.
checkout div - sve div elemente koji su potomci checkout

na kraju u headerComponent dodajemo da Cart ima pravi broj pravi cartQuantity

			
				Video 10


Cilj:
Not Found Component ts html css,
Dodavanje not found componente Na pages


Not found component cemo imati u home i cart-page component a i u food page component.
Isto cemo odratiti preko inputa,koristicemo inpute visible,message,resetlinkmessage,resetlinkroute.

Korisno jer npr mozemo razlicite funkcije da stavljamo u cart page razlicite u home page
npr u cartpage notFoundMessage moze biti Cart Page is Empty u home page Home Page is Empty npr.
resetlinkRouter mozemo staviti da bude drugaciji kao i drugaciji nacin dolazenja do toga da li ce biti 
visible ili nece.


Not Found u cart-page kad nema nijedna dodata hrana u cart.
Not found u food-page kada food id ne postoji.
Not Found u home page kada searchujemo hranu koje nema.





				Video 11


Cilj: Connecting to Backend.
Kreiranje bekend foldera. cd backend nakon toga npm init -y i dobijamo package.json samo
nakon toga treba da skinemo typescript npm install typescript.

Nakon sto smo to uradili dobijamo node module i package lock json. Treba da napravimo novi file
tsconfig.json u njega ubacujemo neke one time config koji nije striktno znati.

ali outDir - dje ce built javascript fajlovi biti locirani.
include valjda govorimo da ce svi typescript fajlovi od src biti transpilovani u javascript.

Create .gitignore da git ignorujemo promjene kao sto su node_modules, tako sto u gitignore napisemo
node_modules.

Kopiranje data.ts u backend src i mjenjamo ih u any[] posto nemamo pristup food modelu i tag modelu.

Instaliranje express cors   npm install express cors.
CORS(Cross-Origin Resoursce Sharing) middleware u Express.js . U NodeJs Cors je bezbednosni mehanizam
koji ogranicava web resurse,kao sto su fontovi,javascript i druge vrste resursa. da budu pozvvani iz drugih domena
osim onog sa kog su orginirani.


Sve skinute se nalazi u dependencies u package.json.

Kreiramo server.ts gde cemo importovati express. prilikom kucanja importa import express from "express";
Dobijamo error da nisu skinuti types/express koje mozemo pritiskom na solution da skinemo.

i onda u devDependencies mozemo da nadjemo @types/express. I imacemo vise typova koje treba skinuti
import cors from "cors"; - opet install.


Cors je generalno potreban zato sto cemo imati dvije localhost adrese prva je localhost:4200 gdje je angular
a druga je localhost:5000 dje ce biti nas bekend.I zato je to valjda samo za vrijeme developmenta.

app.use(cors({
    credentials:true,
    origin:["http://localhost:4200"]
}))

Ovom linijom koda govorimo expressu da koristi kors da ce imat requestove sa localhost:4200 i da koristi credentials.
to jest da ce kredentials biti poslati.

Posto koristimo typescript moramo u bekendu da installirano  npm install ts-node --save-dev.
Takodje postoji i nodemon koji ce da ubrza development valjda i njega cemo koristiti.

Ts-node omogucava izvrsavanje TypeScript koda direktno iz Node-js bez potrebe za prethodnom kompilacijom
u Javascript.

Nodemon je alat za automatsko pracenje promena u fajlovima i ponovo pokretanje aplikacije nakon sto se detektuju
promene.Koristan tokom razvoja jer omogucava automatsko osvezavanje servera ili aplikacije.Bez nodemona
morali bi rucno zaustavljati i ponovo pokretati server nakon svake izmene.

npm install nodemon --save-dev  ili mozda moze oboje sa npm install --save-dev nodemon ts-node.

Nakon toga u package.json u scripts iznad tests dodajemo 
"start": "cd src && nodemon server.ts", Da bi se znalo da pokrecemo ts code pomocu ts-node i da pratimo
preko nodemon.

** I Da bi pokrenuli Server koristimo   npm start 

JSON Formater - Extenzija google za json formatiranje.

Jedan primer get app.get("/api/foods", (req,res) => {
    res.send(sample_foods);
})

Pravimo get metode i uz pomoc onih metoda u food service.


Ovako je izgledalo dobavljanje podataka u part 1 konektovanju sa bazom preko api.
/* 

app.get("/api/foods", (req,res) => {
    res.send(sample_foods);
})

app.get("/api/foods/search/:searchTerm", (req,res) => {
    const searchTerm = req.params.searchTerm;
    const foods =  sample_foods
    .filter(food => food.name.toLowerCase()
    .includes(searchTerm.toLowerCase()));
    res.send(foods);
})

app.get("/api/foods/tags", (req,res) => {
    res.send(sample_tags);
})

app.get("/api/foods/tag/:tagName", (req,res) => {
    const tagName = req.params.tagName;
    const foods = sample_foods
    .filter(food => food.tags?.includes(tagName));
    res.send(foods);
})

app.get("/api/foods/:foodId",(req,res) => {
    const foodId = req.params.foodId;
    const food = sample_foods
    .find(food => food.id == foodId);
    res.send(food);
})

*/


				Video 12


Cilj:   Cilj je da sva hrana dolazi iz bekenda.Na home page food page.a ne iz data.ts sa frontenda.

Dodavanje urls.ts na frontend. dodajemo const BASE_URL = "http://localhost:5000";
a kad dodamo na pravi server bice ImeAplikacije.::::.com

u urls.ts Dodajemo konstante / url-ove npr FOODS_URL,foodBySearchUrl...

-Nakon toga dodavanje HtppClient Modula u app module.

-Nakon toga updejtovanje Food Servisa. Posto HTTP client valjda salje observable a ne 
raw data kao sto je food moramo da promjenimo kod u food service.

i sada getAll metoda izgleda ovako.
  getAll(): Observable<Food[]>{
    return this.http.get<Food[]>(FOODS_URL);
  }

Nakon sto se izmjenjaju sve metode prilagode metodama na bekendu.
Moramo da izmenjamo i upotrebu tih metoda u komponentama.

U home page komponenti smo napravili observable jer ima vise this.foods 
a na druge komponente.

Nakon ovoga svi podatci o hrani i tagovima dolazi iz bekenda.



			Video 13

Cilj: Login Page - front - back

Login Page generisanje komponente,route,ts,html,css,Reactive Forms Module.

Koriscenje FormGroup u ts + koriscenje formBuildera u konstruktoru koji olaksava rad sa formgroup

Takodje koriscenje Validators iz Angulara za validiranje.

Znaci u Angularu FormGroup i FormBuilder su deo Reactive Forms modula koji omogucava efikasno
upravljanje formama u Angular Aplikaciji.

A da bi mogli loginForm koji je tipa formGroup koristiti u html-u moramo da importujemo ReactiveFormsModule
( sve ovo dolazi iz angular/forms ) 

Nakon sto smo zavrsili izgled login komponente dodajemo i Login API.
Takodje i koriscenje JSON, JsonWebTokena, Testiranje Pomocu Postmena.

prva post api metoda.

app.post("/api/users/login", (req,res) => {
    const body = req.body;
})

Problem je sto se ovo salje kao json a Express ne koristi json kao default. 
i zato u server.ts dodajemo jos i app.use(express.json())

u Data.ts cemo dodati neke Sample_usere (sample_users)

Da bi koristili JsonWebToken moramo da ga instaliramo na bekend. 
Preko komande - npm install jsonwebtoken i da ga importujemo u server.ts i takodje isntaliramo
kao types.

proces generisanja tokena je sign  jwt.sign(); koji ima 3 argumenta.

-Prvi argument je payload  - sta zelimo da enkodiramo npr email u ovom sllulcaju.
- Drugi arugment je - secret ili private key string. ( sa njim moze da se dekoduje token)
- Treci argument je -  options opcije npr expiredTime expiresIn

app.post treba kao response ako je dobro da vrati token response ili ti jwttoken.
ako nije code 400 sa porukom sta je poslo po zlu.

Za testiranje ovoga koristicemo Postman.
Koristimo post request sa localhost:5000/api/users/login
Body Json { "email":"jane..", "password":"..."} i ako takav user postoji u data.ts vratice code 
200 i podatke o user-u sa njegovim tokenom.
A ako ne postoji code 400 i poruku da Email ili password nisu validni


			
			Video 14

Cilj: 
Treba da povezemo login componentu na frontend sa login api-om.
A to cemo uraditi tako sto cemo generisati User Service, User model, User subject.
login metode,local storage metode,logout metoe,itd....


u userService kreiramo novi userSubject tipa BehavioourSubject<User> on moze da ima 
read i write mode u njemu ali mi ne zelimo da ista van userService da koristi write unutar
User objekta.
Zato kreiramo userObservable koji ce koristiti userSubject.asObservable();
da bi imali nesto sto je samo readOnly.

Koristicemo i interface user Login a glavna razlika izmedju interfejsa i klase je da sa interfejsom
ne mozemo kreirati novu instancu i po defaultu svi podatci u Interfejsu su required zato se ne
koristi ! ili ?. (  za interfejse u shared kreiramo novi folder interfaces dje cemo stavljati sve interfejse)

kod http.post uvek moramo pored url da posaljemo i body.
Ako bi koristili subscribe na return kod login metode onda bi promjenili tip returna u Subscribtion a ne ObservableUser
zato koristimo pipe koji ne mjenja povratni tip a on ima neke svoje operatore
kao sto su tap i next.

tap je operator koji se koristi kada zelite pogledati ili izvrsiti neku akciju bez izmena na samom
toku podataka.

next se obicno koristi kao callback funkcija koja se poziva kada se emituje sledeca vrednost u toku
podataka.Ili u ovom slucaju Happy Massage uspjesni message ?

error se koristi za definisanje callback funkcije koja se poziva kada se desi greska u toku podataka.

callback funkcija je funkcija koja se prosledjuje kao argument drugoj funkciji i poziva se nakon
izvrsavanja te druge funkcije.

Za uspjesno loginovanje koristicemo ngx-toastr  poruku  a da bi to uradili moramo da importujemo
u modulu,importujemo browserAnimationsModule i dodamo stil u angular.json.
Ali prije toga svega treba prvo da ga instaliramo na front - npm install ngx-toastr.

Ovde moze doci do greske zbog verzija ng-toastr koja radi sa posebnom verzijom angulara.
Npr u ovom trenutku nisam mogao da skinem jer zadnja verzija ngx-toastr radi samo sa angular 16

zato treba da skinemo odredjenu verziju koja radi sa Angular 15 npm install ngx-toastr@^15.2.0
ni to nije proslo pa sam uradio
npm install ngx-toastr --force  ( npm install ngx-toastr --save --force ) i uspjelo je sa warning-s

Znaci dodajemo ToastrModule i BrowserAnimationsModule.
I takodje moramo u angular.json u styles da dodamo  "node_modules/ngx-toastr/toastr.css" ispod
glavnog css.

Takodje u appmodule toastrModule-u mora da se doda ovo
   ToastrModule.forRoot({
      timeOut: 3000,    // vrijeme zadrzavanja
      positionClass:"toast-bottom-right", // klasa definisana u css toastr.css za position
      newestOnTop:false  // cuvanje proslih poruka 
    })

Return url uglv sluzi da nas vrati na poslednju aktivnu rutu ja bi rekao. 
Uglv da nas nakon uspjesnog submitovanja ili neuspjesnog redirektuje.

Malo konfuzniji video.(13-15 minut). Nakon sto je submit gotov treba restartovati angular frontend server
Zato sto kad se mijenja angular.json mora da se restartuje server.

Nakon sto smo uspjeli da prikazemo poruke nakon uspjesnog submita treba i da prikazemo
toastr nakon neuspjesnog logina to jest kad prodje frontend provjere a ne bekend da postoji user
sa takvim parametrima.

Treba negde da sacuvamo tog usera sto se loginovo a to cemo uraditi u localstorage.

nakon sto napravimo set i get user local storage metode mozemo za userSubjecta da stavimo da je on
novi getUserFromLocalStorage posto ako ga nema pice samo new User kao i prije

Nakon sto smo to uradili vrijeme je da iz Headera Hardkodovanog imena zamjenimo sa 
Pravim loginovanim userom(Njegovim imenom).To smo uradili tako smo se se subscribovali
na userService.userObservable i stavljamo da je trenutni user taj zadnji user.

nakon toga u userService dodajemo logout funkciju koju cemo da upotrebimo u header komponenti.

*** koliko sam skontao servise konstruktora ne mozes da koristis van konstruktora ako ne dodas private.



				Video 15

Cilj: Valjda -  Razdvajanje login page na componente
Pravljenje komponenti za login page,
input container,input validation, text input, default button.

Pravimo input container komponentu koja ce imati label i background color.
imacemo u html ng-content tag novi tag u koji ce da se projektuje kontent koji budemo 
stavili izvan nje to jest u drugoj komponenti kad budemo koristili selektor ove komponente.
To jest bilo sta sto stavimo izmedju selektora komponente ce se smatrati kao da je unutar ng-contenta.

Zatim kreiramo posebnu komponentu za error Message kod logina.
Input-Validation.
Takodje koristimo Inpute() i AbstractControls kao tip koji dolazi iz angular forms koji je isti tip
kontrole kao sto imamo vec u login page.

Dodavanje Object.keys,ngOnChanges 

Object.keys() - funkcija kada zelimo da radimo sa kljucevima objekta, i kad je potreban niz tih kljuceva.

ngOnChange je Angular hook koji se poziva svaki put kada se vrednost input propertija komponente promene
omogucava da se reaguje na te promene i izvrse odredjene akcije.

changes objekat sadrzi promene u ulaznim svojstvima. ( instanca tipa SimpleChanges koji sadrzi informacije o prethodnoj
i trenutnoj vrednosti svojstva)

Sada zelimo da input-container input i input-validation stavimo sve u jednu komponentu.
A to je Text Input Componenta.


Nova stvar koju smo tamo naucili takodje dodajemo inpute ali sada imamo kod imputa tip koji moze biti
@Input()
  type: "text" | "password" | "email" = "text"; 

Samo text password ili email a default je text.

input::placeholder u css mjenjanje placeholdera.

Nakon sto smo zavrsili TextInput koji je sjajan feature jer je sad dodavanje novih elemenata poprilicno lako.
pravimo i default button.

DefaultButton - To mi nije jasno bas zasto ali pravimo i komponentu samo za button.
Kod njega dodajemo dosta inputa i jedan novi Output()
@Output() - koristimo jer je button i jer moramo da mu damo onclick event i da bi poslali event 
moramo da koristimo output.


 [ngStyle]="{
        color:color,
        'background-color':bgColor,
        'font-size.rem':fontSizeRem,
        'width.rem':widthRem
    }"

' ' - moramo jer imaju - kod font size i background color i takodje jer imamo .rem koji pokazuje koji unit se
koristi.

Sad npr ako ocemo da dodamo novo polje za login sve sto treba da uradimo je 
   <text-input
            [control]="fc.username"
            [showErrorsWhen]="isSubmitted"
            type="text"
            label="Username"
            ></text-input>
i dodamo validatore za njega npr da je required i to je to.


				
				Video 16 Najbitniji cas. Uvodjenje MongoDb




















